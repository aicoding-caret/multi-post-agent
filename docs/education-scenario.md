# AI 에이전트 개발 및 바이브코딩 실습 교육 시나리오

본 교육 시나리오는 AI오픈소스 코딩 도구인 Caret을 이용한 라이브 서비스 수준의 바이브 코딩 환경 학습을 원하는 개발자 혹은 IT관련 학생을 대상으로 하며 API를 통한 웹 애플리케이션과 AI Agent의 개발 구성등을 학습하고 완전한 무료로 가능한 실습환경 정보를 제공을 목표합니다.

## 🎯 교육 목표

* AI 에이전트의 기본 개념과 작동 원리를 이해합니다.
* Caret을 활용한 "바이브코딩" 개발 프로세스를 체험합니다.
* 실제 프로젝트 요구사항을 분석하고, AI와 협업하여 문서를 작성하고 코드를 구현하는 과정을 학습합니다.
* LangGraph를 이용한 AI 워크플로우 구성 및 활용법을 익힙니다.
* **로컬 웹 애플리케이션을 통해 Blogger.com에 원하는 스타일로 콘텐츠를 생성하고 포스팅하는 AI 에이전트 개발을 목표로 합니다.**

## ⏰ 예상 소요 시간

* 총 3시간 (실습 환경 및 참여자 수준에 따라 변동 가능)

## 📚 교육 과정

### 1. 오리엔테이션 (약 15분)
* [Caret을 이용한 Multi Post Agent 오픈소스 프로젝트 교육 슬라이드](../resources/Caret을%20이용한%20Multi%20Post%20Agent%20오픈소스%20프로젝트%20교육%20슬라이드.pdf)

* **AI 에이전트란 무엇인가?**
    * Caret과 함께하는 "바이브코딩"(AI와 실시간으로 소통하며 함께 코드를 작성하고 문제를 해결하는 개발 방식) 소개
    * 개발할 미니 프로젝트(LangGraph와 Blogger API를 활용한 자동 콘텐츠 스타일 변환 및 포스팅 에이전트) 개요
    * 전체 실습 과정 및 결과물 안내

### 2. 개발 환경 설정 (약 30분)

1. **Visual Studio Code (VS Code) 설치**
    * [VS Code 공식 홈페이지](https://code.visualstudio.com/)에서 다운로드 및 설치 안내
    * Mermaid Plugin 설치 (https://marketplace.visualstudio.com/items?itemName=MermaidChart.vscode-mermaid-chart)
    * PDF 뷰어 확장 프로그램 설치 (https://marketplace.visualstudio.com/items?itemName=tomoki1207.pdf)

    **1.1. VS Code 관리자 권한 실행 (Windows 사용자 권장)**
        * Windows 환경에서 Python 가상 환경(`venv`) 생성 및 패키지 설치 시, 간혹 권한 문제로 인해 가상 환경 내의 `site-packages` 디렉토리에 패키지가 정상적으로 설치되지 않고 사용자 전역 경로에 설치되는 경우가 발생할 수 있습니다. (예: "Defaulting to user installation because normal site-packages is not writeable" 메시지 발생)
        * 이러한 문제를 예방하고 원활한 실습 환경을 위해, **VS Code를 관리자 권한으로 실행**하는 것을 권장합니다.
        * **실행 방법:** VS Code 아이콘을 마우스 오른쪽 버튼으로 클릭 후, "관리자 권한으로 실행"을 선택합니다.

2. **Git 설치 및 프로젝트 클론**
    * [Git 공식 홈페이지](https://git-scm.com/)에서 다운로드 및 설치 안내
    * 터미널 또는 Git GUI를 사용하여 교육용 프로젝트 저장소 클론:
        ```bash
        git clone https://github.com/aicoding-caret/multi-post-agent.git
        ```
    * 클론된 프로젝트 폴더를 VS Code에서 열기

3. **Google 계정, 무료 크레딧 설정, 블로그, Outh, .env파일 설정 (약 15분)**
    * Blogger API를 사용하기 위해 Google 계정을 준비하고 필요한 API 키 및 OAuth 2.0 설정을 진행합니다. 

    #### 1. 구글 계정 신규 생성
    
    * **URL:** [https://accounts.google.com/](https://accounts.google.com/)
    * **필요 정보:**
        * 계정 이름
        * 계정 이메일
        * 복구 이메일 혹은 전화번호
    
    #### 2. Gemini API Key 발급
    
    1. **API Key 발급 페이지 접속:**
        * [https://aistudio.google.com/apikey](https://aistudio.google.com/apikey)
    2. **API Key 생성 및 복사:**
        * "API 키 만들기"를 통해 Key를 생성하고 복사합니다. (이 정보는 Caret의 Gemini API 설정 등에 사용됩니다.)
    
    ##### 2.1. Google Cloud 무료 크레딧 (선택 사항)
    
    * Google Cloud Console에서 "$300 무료 크레딧" 제공 페이지를 확인합니다.
        * **필요 정보:** 개인 신용카드, 주소 등
        * **확인 사항:** "바로 결제로 이동"하는 경우 크레딧이 제공되지 않을 수 있습니다. "$300(약 43만원)의 무료 크레딧으로 90일간 Google Cloud를 체험해 보세요."와 같은 문구가 표시되어야 합니다.
    
    > **주의사항:** Google AI 스튜디오 API Key 페이지에서 일반 계정 활성화, 결제 계정 연결, 그리고 Tier 1으로의 변경까지 모두 완료되었는지 확인해야 무료 크레딧 사용이 가능합니다.
    
    #### 3. Blogger 가입 및 API 설정 (OAuth 포함)
    
    ##### 3.1. Blogger 가입
    1. [Blogger 웹사이트](https://www.blogger.com)에 접속하여 Google 계정으로 가입하고 새 블로그를 생성합니다.
    
    ##### 3.2. Google Cloud Console에서 Blogger API 활성화
    1. [Google Cloud Console](https://console.cloud.google.com/)에 접속합니다.
    2. 프로젝트를 선택하거나 새 프로젝트를 생성합니다.
    3. "API 및 서비스" > "라이브러리"로 이동합니다.
    4. "Blogger API"를 검색하고 "사용 설정"합니다.
      https://console.cloud.google.com/marketplace/product/google/blogger.googleapis.com
    
    
    ##### 3.3. OAuth 2.0 클라이언트 ID 설정
     - OAuth를 이용할 앱의 정보를 설정하는 단계 입니다.
    1. "API 및 서비스" > "사용자 인증 정보"로 이동합니다.
    2. "+ 사용자 인증 정보 만들기" > "OAuth 클라이언트 ID"를 선택합니다.
    3. **애플리케이션 유형**을 "웹 애플리케이션"으로 선택합니다.
    4. **승인된 JavaScript 원본** 설정:
        * 로컬 개발 환경에서 테스트하기 위해 웹 애플리케이션이 실행되는 주소를 추가합니다.
        * 예시: `http://localhost:8000` 
    5. **승인된 리디렉션 URI** 설정:
        * OAuth 2.0 인증 후 Google이 사용자를 리디렉션할 애플리케이션의 경로를 추가합니다.
        * 이 URI는 FastAPI 애플리케이션에서 OAuth 콜백을 처리할 엔드포인트 경로와 일치해야 합니다.
        * 예시: `http://localhost:8000/auth/google/callback` 
        * **참고:** `docs/development-guide.md`의 `app/routers/post_router.py` 설계 시 `/auth/google/callback` 경로를 사용하므로 경로를 일치시켜야 합니다.
    6. "만들기"를 클릭하면 클라이언트 ID와 클라이언트 보안 비밀이 생성됩니다.
        * 이 정보는 프로젝트 루트의 `.env` 파일에 `GOOGLE_CLIENT_ID`와 `GOOGLE_CLIENT_SECRET`으로 안전하게 보관해야 합니다.
    7. "블로그" 만들기
       https://www.blogger.com/about/ 에서 만들기를 클릭하여 블로그를 만듭니다.
    
    ##### 3.4. OAuth 동의화면 설정
     - OAuth이용시 해당 화면에 표기 하기 위한 정보를 설정하는 단계 입니다.
    1. "API 및 서비스" > "OAuth동의 화면"으로 이동합니다.
    2. "+ 시작하기"버튼을 선택합니다.
     * 앱정보 : 앱 이름 입력, 사용자 지원 이메일은 계정 메일 선택
     * 대상 : 외부
     * 연락처 정보 : 자유롭게 이메일 입력 합니다. Google에서 프로젝트 변경사항에 대해 알림을 보내기 위한 용도입니다.
     * 완료 : 사용자 데이터 정책에 동의
    
    
    ##### 3.4. 블로그 ID 확인 방법
    
    Blogger API를 사용하여 특정 블로그에 글을 게시하거나 정보를 가져오려면 해당 블로그의 고유 ID가 필요합니다.
    
    1. **Blogger 대시보드 접속:**
        * [https://www.blogger.com](https://www.blogger.com) 에 접속하여 Google 계정으로 로그인합니다.
    2. **해당 블로그 선택:**
        * ID를 확인하고자 하는 블로그를 선택하여 해당 블로그의 관리 페이지로 이동합니다. (예: 글 목록, 설정 등)
    3. **URL에서 블로그 ID 확인:**
        * 브라우저의 주소창을 확인합니다. URL은 일반적으로 다음과 같은 형식 중 하나로 표시됩니다:
            * `https://www.blogger.com/blog/posts/{블로그_ID}`
            * `https://www.blogger.com/blogger.g?blogID={블로그_ID}#allposts`
            * `https://www.blogger.com/u/{숫자}/blog/page/edit/{블로그_ID}/{페이지_ID}`
            * `https://www.blogger.com/u/{숫자}/blog/settings/{블로그_ID}`
        * 위 형식에서 `{블로그_ID}` 부분에 해당하는 긴 숫자 문자열이 해당 블로그의 고유 ID입니다.
        * 예시: 마스터께서 알려주신 `https://www.blogger.com/u/5/blog/settings/7130095174209823806` 의 경우, 블로그 ID는 `7130095174209823806` 입니다.
    
    이 블로그 ID는 API 요청 시 `blogId` 매개변수 값으로 사용됩니다.
    
    #### 5. 획득한 인증 정보 및 Blog ID를 `.env` 파일에 설정
    
    위 과정들을 통해 얻은 Google Cloud 프로젝트의 **클라이언트 ID**, **클라이언트 시크릿**, 그리고 포스팅할 **Blogger의 Blog ID**는 실제 애플리케이션 코드에서 안전하게 사용하기 위해 환경 변수로 관리하는 것이 좋습니다.
    
    1. **`.env` 파일 준비:**
        * 프로젝트 루트 디렉토리에 `.env.template` 파일이 있다면, 이를 복사하여 같은 위치에 `.env` 파일을 생성합니다. (예: 터미널에서 `copy .env.template .env` 또는 `cp .env.template .env`)
        * 만약 `.env.template` 파일이 없다면, 직접 `.env` 파일을 생성합니다.
    2. **`.env` 파일에 정보 입력:**
        * 생성하거나 준비된 `.env` 파일을 열고, 다음과 같은 형식으로 앞에서 획득한 정보들을 입력합니다. 
    
            ```dotenv
            # .env 파일 설정 방법
            GEMINI_API_KEY="위의 API KEY입력"
            GOOGLE_CLIENT_ID="OAuth설정한 앱 클라이언트 ID입력"
            GOOGLE_CLIENT_SECRET="OAuth설정한 앱 클라이언트 KEY입력"
            BLOG_ID="생성한 BLOG ID입력"
            ```
        * **`GOOGLE_CLIENT_ID`**: "OAuth 2.0 클라이언트 ID 설정" 단계에서 확인한 클라이언트 ID입니다.
        * **`GOOGLE_CLIENT_SECRET`**: "OAuth 2.0 클라이언트 ID 설정" 단계에서 확인한 클라이언트 보안 비밀입니다.
        * **`BLOG_ID`**: "블로그 ID 확인 방법" 섹션을 참고하여 확인한 여러분의 Blogger 블로그 ID입니다.
    3. **보안:**
        * `.env` 파일은 민감한 정보를 담고 있으므로, 절대로 Git 저장소에 직접 커밋하거나 외부에 노출되지 않도록 주의해야 합니다. 프로젝트의 `.gitignore` 파일에 `.env`가 포함되어 있는지 확인하세요.
    
    이렇게 `.env` 파일에 설정된 값들은 애플리케이션 실행 시 `app/core/config.py`와 같은 설정 파일을 통해 안전하게 로드되어 사용됩니다.

4. **Caret 설치 (VSIX 파일)**
    * 프로젝트 내 `resources\caret\caret-dev-3.10.1-20250516-094208.vsix` 파일을 사용합니다.
    * **설치 방법:** VS Code 확장 탭(단축키: `Ctrl+Shift+X`)에서 우측 상단의 '...' 메뉴를 클릭한 후, 'VSIX에서 설치...(Install from VSIX...)'를 선택하여 다운로드한 `.vsix` 파일을 지정합니다.
    * **참고 (Caret UI 위치):** Caret은 설치 후 VS Code의 보조 사이드바에 표시될 수 있습니다. (보기(V) > 모양(A) > 보조 사이드바 표시/숨기기, 단축키: `Ctrl+Alt+B`)
    * 2025년 6월 3일 현재 Caret은 마켓플레이스에 정식 배포되지 않아 VSIX 파일로 실습합니다. 현재 최신 버전의 기능을 통합하며 상용화를 준비 중입니다.
        
    * **Caret 초기 설정 (API Key):**
        * Google 계정으로 얻은 Gemini API Key를 Caret에 설정하는 것을 권장합니다.
        * 작업의 복잡도에 따라 모델을 선택할 수 있습니다.
            * 간단한 작업: "Gemini 1.5 Flash" (또는 유사 모델)
            * 복잡한 작업: "Gemini 1.5 Pro" (또는 유사 모델)
        * (참고: 정확한 최신 모델명은 Google AI Studio에서 확인해주세요.)
    * **API 사용 비용 관련:**
        * "Gemini 1.5 Pro"와 같은 고급 모델은 사용량에 따라 비용이 발생할 수 있습니다. (본 교육 실습에서는 미미한 비용이 예상됩니다.)
        * Google Cloud의 과금 정보는 실시간으로 반영되지 않을 수 있으나, Caret 인터페이스 내에서는 대화별 예상 비용이 표시되니 참고하시기 바랍니다.
    
5. **Python 및 LangGraph 환경 준비**
    * 본 실습은 Langraph 를 포함 합니다.
    * Python 최신 버전 설치 ([Python 공식 홈페이지](https://www.python.org/downloads/) 참조)
    * VS Code 내 Python 확장 프로그램 설치
    * 터미널에서 LangGraph 및 관련 라이브러리 설치:
        ```bash
        pip install langgraph langchain langchain_openai langchain_anthropic fastapi uvicorn httpx
        ```
    * (참고) LangGraph는 Python 기반이므로, 이 부분 실습은 Python 환경 설정이 필요합니다.

    * **LangGraph 설치 확인:**
        LangGraph가 제대로 설치되었는지 확인하려면, 터미널에서 `python -c "import langgraph"` 명령어를 실행하여 에러가 없는지 확인합니다. 에러가 없다면 LangGraph가 성공적으로 설치된 것입니다.

### 3. Caret 설정 및 기본 사용법 익히기 (약 15분)

1. **템플릿 캐릭터(페르소나) 설정**
    * Caret 설정에서 제공되는 기본 템플릿 캐릭터 선택 및 적용
    * 캐릭터 변경에 따른 AI 응답 스타일 변화 관찰
    * (참고) 템플릿 캐릭터 관련 이미지 파일 (alpha-default.png, alpha-thinking.png)과 페르소나 JSON 파일 (alpha-persona-rule.json)은 `resources/caret` 폴더에 있습니다.

2. **커스텀 인스트럭션 편집을 통한 개인별 AI 페르소나 만들기**
    * Caret의 커스텀 인스트럭션 설정 파일 열기
    * AI의 호칭, 말투, 역할 등을 수정하며 나만의 AI 페르소나 정의 실습
    * 예: `마스터`라는 호칭을 `주인님`으로 변경하고, 말투를 `~냥`으로 변경하면 AI가 `주인님, 말씀하세요냥~`과 같이 응답합니다.
    * 수정된 인스트럭션에 따라 AI의 반응이 어떻게 달라지는지 확인
    
3. **`.caretrules` 파일 편집 및 프로젝트 규칙 학습**
    * 프로젝트 루트의 `.caretrules` (또는 `.caretrules.ko.md`) 파일 내용 확인
    * 간단한 규칙을 추가하거나 수정해보고, Caret의 응답이 규칙에 따라 제어되는지 관찰
    * 프로젝트별로 AI의 행동 지침을 설정하는 방법 학습
    
4. **모드 규칙(Mode Rules) 편집 및 AI 에이전트 역할별 차이 학습**
    * Caret의 모드별 규칙 설정 (예: ARCH MODE, DEV MODE 등) 확인
    * 각 모드별로 AI의 전문 분야나 응답 스타일이 어떻게 다른지 체험
    * 상황에 맞는 AI 모드를 선택하여 활용하는 방법 학습

5. **💡 Caret 사용 추가 팁 (알아두면 유용해요!)**
    * **알파(페르소나) 표시 관련:** 간혹 Caret 모드(ARCH, DEV 등) 변경 시 페르소나 표시가 일시적으로 기본값으로 돌아가는 현상이 발생할 수 있습니다. 이 경우, Caret 설정에서 페르소나 파일(예: `resources/caret/alpha-persona-rule.json`)을 다시 선택하거나 커스텀 인스트럭션 내용을 다시 적용하면 원래대로 돌아옵니다.
    * **파일을 콕 집어 알려주고 싶을 때 (`@` 활용):** AI에게 특정 파일에 대해 이야기하고 싶다면, 메시지 창에 `@`를 치고 파일 이름을 입력해보세요.
        * **만약 `@`가 잘 안된다면?** 걱정 마세요! AI에게 파일 이름이나 경로의 일부를 알려주거나(예: "`docs` 폴더의 `requirement` 파일이요!"), VS Code에서 파일 오른쪽 클릭 > "경로 복사" 해서 붙여넣어주면 알파가 찰떡같이 알아들을 거예요! ☕

### 4. 프로젝트 요구사항 문서(PRD) 설명 및 편집 (AI 협업 심화)

1. **`docs/` 폴더 내 프로젝트 요구사항 문서 확인**
    * 교육용으로 간소화된 프로젝트 요구사항 문서 (`docs/requirement.md`) 내용 함께 읽기.
    * 문서의 주요 기능, 사용자 시나리오, 시스템 구조 등을 파악합니다.

2. **요구사항 및 Task 문서 연계 수정 실습 (AI 협업)**
    * **상황 제시:**
        * 때로는 프로젝트 진행 중, 특정 기능(Task)을 구체화하다 보면 초기의 요구사항 정의를 더 명확하게 하거나 확장해야 할 필요가 생깁니다.
        * 예를 들어, `docs/tasks/005-langgraph-basic-and-transform.md` (콘텐츠 변환 기능 구현 Task)에서 "전문적인 블로그 스타일로 변환"이라는 구체적인 변환 목표가 있는데, `docs/requirement.md`의 "콘텐츠 스타일 변환" 항목이 이를 충분히 반영하지 못하거나, "콘텐츠 요약 기능"과 같은 새로운 아이디어가 추가될 수 있습니다.
    * **실습 목표:** 이러한 상황에서 Caret과 협력하여 `docs/requirement.md`와 관련 Task 문서(`docs/tasks/005-...md`) 두 곳의 내용을 일관성 있게 업데이트하는 과정을 체험합니다.
    * **왜 두 문서를 수정해야 하는가?**
        * **`docs/requirement.md` (요구사항 문서):** 프로젝트의 공식적인 범위와 목표를 정의하는 기준 문서입니다. 모든 기능은 여기에 명시되어야 합니다.
        * **`docs/tasks/...md` (Task 문서):** 개별 기능의 구체적인 구현 방법을 기술합니다. 이 내용은 요구사항을 기반으로 작성되지만, 때로는 Task 수준의 논의가 요구사항을 업데이트하는 계기가 되기도 합니다.
        * 따라서, 두 문서 간의 정합성을 유지하는 것은 프로젝트 관리의 매우 중요한 부분입니다.
    * **Caret에게 수정 요청하는 방법:**
        * **상황 설명 및 목표 전달**
            * 예: "Caret, `docs/tasks/005-langgraph-basic-and-transform.md`를 보니 '전문적인 블로그 스타일 변환' 기능이 있는데, `docs/requirement.md`의 '콘텐츠 스타일 변환' 부분에 이 내용과 함께 '콘텐츠 요약 기능'도 추가하고 싶습니다. 두 문서의 내용을 일관성 있게 업데이트해주세요."
        

### 5. "바이브코딩" 실습: AI와 함께 미니 프로젝트 개발 (약 90분)

* **목표:** 로컬 웹 애플리케이션(FastAPI) UI에서 텍스트를 입력받아, LangGraph를 통해 특정 스타일로 변환 후, Blogger.com에 API를 사용하여 포스팅하는 기능을 구현합니다.

    **💡 태스크 진행 방식 안내 (Caret과 함께하는 단계별 개발)**

    본 실습의 각 개발 태스크(`docs/tasks/` 폴더 내의 `001-*.md`, `002-*.md` 등)는 독립적인 목표를 가지고 진행됩니다. 효과적인 AI 협업 실습을 위해 다음 방식을 따라주세요.

    1. **새로운 태스크 시작 시 (Caret에게 컨텍스트 제공 및 주의사항):**
        * 하나의 태스크가 완료되거나, 새로운 태스크를 시작할 때는 **새로운 Caret 채팅 세션을 시작**하는 것을 강력히 권장합니다.
            * **이유:** 이전 세션의 대화 내용이 다음 태스크에 의도치 않은 영향을 주거나, 대화 맥락이 너무 길어져 Caret이 중요한 세부 사항을 놓치거나 혼란스러워하는 것을 방지하고, 각 태스크를 명확하고 깨끗한 상태에서 시작하기 위함입니다.
        * **중요! 이전 세션의 정보 전달 및 문서화의 핵심 역할:**
            * AI는 긴 대화를 완벽하게 기억하지 못하며, 이전 대화 내용이 내부적으로 요약되어 전달되는 과정에서 중요한 정보가 소실될 수 있습니다.
            * 따라서, 이전 세션에서 논의되었던 중요한 결정 사항, 변경된 요구사항, 또는 다음 작업에 반드시 반영되어야 하는 내용들은 **반드시 문서화하여 기록**해야 합니다. (예: 각 태스크 문서의 "진행-상황-및-특이사항" 섹션, 또는 별도의 결정 로그 파일 활용)
            * 새로운 세션을 시작할 때는, AI에게 이러한 **문서화된 내용을 다시 확인하도록 명시적으로 지시**하거나, **핵심 내용을 요약하여 다시 전달**하는 것이 매우 중요합니다. 이렇게 해야 작업의 연속성과 일관성을 유지할 수 있습니다. **체계적인 문서화는 AI와의 성공적인 협업을 위한 가장 중요한 열쇠 중 하나입니다.**
        * **Caret에게 컨텍스트 제공 및 태스크 진행 방식 예시 (본 실습 적용 방식):**
            * **1단계 (프로젝트 전체 컨텍스트 인식 요청):** Caret에게 주요 프로젝트 문서들을 읽고 전반적인 업무 계획을 수립하도록 요청합니다.
                ```
                프로젝트 주요 문서들 먼저 읽고 다 읽고 어떤 업무를 어떻게 할지 설명해줘
                - `README.md`
                - `docs/requirement.md`
                - `docs/development-guide.md`
                - `docs/tasks/task-list.md` 
                ```
                
                * `.caretrules` mode의 rules, 사용자 기본 규칙은 자동으로 Caret에서 시스템프롬프트로 들어감

            * **2단계 (태스크 기반 점진적 개발):** Caret이 수립한 계획 (주로 `docs/tasks/task-list.md` 기반)에 따라 각 태스크를 순차적으로 진행하도록 지시합니다. Caret은 각 태스크 문서를 참조하여 작업을 수행하고, 완료 시 해당 태스크 문서의 체크리스트 및 진행 상황을 업데이트하며, `task-list.md`의 상태도 변경합니다. 사용자는 Caret의 작업 결과(코드, 문서 수정 내용 등)를 검토하고 피드백을 제공하며, 문제 발생 시 함께 해결합니다.
                ```
                응, 태스크 00X번부터 시작해줘. / 이 부분은 이렇게 수정해줘. / 테스트 결과는 이렇고, 다음은 어떻게 할까?
                ```
    2. **Caret의 역할:**
        * Caret은 지시받은 태스크 문서를 읽고, 해당 문서의 목표와 체크리스트를 기준으로 작업을 수행합니다. 사용자가 제공한 추가적인 컨텍스트와 문서화된 내용을 최우선으로 고려합니다.

    3. **태스크 완료 시 (AI의 문서화 작업 포함):**
        * 하나의 태스크가 성공적으로 완료되면, Caret은 다음의 문서화 작업을 수행합니다:
            1. 해당 **개별 태스크 문서** (`docs/tasks/00X-task-name.md`)를 업데이트합니다:
                * 문서 내의 **체크리스트** 항목들을 모두 완료(`[x]`)로 표시합니다.
                * "**진행-상황-및-특이사항**" 섹션에 해당 태스크 수행 중 발생한 주요 결정 사항, 특이점, 시작 및 완료 시간, 총 소요 시간 등을 간략히 기록합니다. (이때, 사용자로부터 전달받은 중요한 논의 내용이나 결정 사항을 반드시 포함합니다.)
                * 문서 상단의 "**상태:**" 필드를 `to-do`에서 `done`으로 변경합니다.
            2. **태스크 목록 요약 문서** (`docs/tasks/task-list.md`)를 업데이트합니다:
                * 해당 태스크 ID의 "**상태**" 컬럼을 `done`으로 변경합니다.
                * "**비고**" 컬럼에 완료 일시 (예: `완료 (YYYY-MM-DD HH:MM)`)를 기록합니다.
        * 위의 모든 문서 업데이트가 완료되면, Caret은 사용자에게 태스크 완료 및 문서 업데이트 완료를 보고하고 다음 지시를 기다립니다. **자동으로 다음 태스크로 넘어가지 않습니다.**
        * 사용자는 완료된 내용과 업데이트된 문서를 확인하고, 다음 태스크 진행 여부 및 시작을 Caret에게 다시 명시적으로 지시합니다.
        * **중요: 단계별 테스트 및 피드백 루프:** 각 태스크의 주요 기능 구현 후, 또는 Caret이 코드 변경을 제안하여 적용했을 때, 교육생은 **반드시 직접 애플리케이션을 실행하여 기능이 의도대로 작동하는지 테스트**해야 합니다.
            * **테스트 종류 (예시):**
                * **기본 실행 테스트:** 서버가 오류 없이 시작되는가? 웹 페이지가 정상적으로 로드되는가? (Uvicorn 서버 로그 및 브라우저 확인)
                * **기능 단위 테스트:** 특정 버튼 클릭, 입력 값에 따른 UI 변화, API 호출 및 응답 확인 (브라우저 개발자 도구 - 네트워크 탭, 콘솔 탭 활용), 서버 로그 확인.
                * **데이터 검증:** LLM 변환 결과, Blogger 포스팅 내용 등이 요구사항에 맞게 생성되었는지 확인.
            * **피드백 제공:** 테스트 결과(성공, 실패, 오류 메시지, 예상과 다른 동작 등)를 구체적으로 Caret에게 전달하여 다음 작업 방향을 함께 논의하거나 수정을 요청합니다. 이러한 피드백 루프는 Caret과의 협업에서 매우 중요합니다.

    이러한 방식으로 각 태스크를 명확히 구분하고 Caret이 문서화까지 책임지도록 함으로써, Caret과의 커뮤니케이션을 더 효과적으로 연습하고 각 개발 단계를 체계적으로 관리할 수 있습니다.

### 참고: `work-logs` 폴더를 활용한 다른 AI 협업 방식 예시

본 실습에서는 `docs/tasks/` 내의 구체화된 태스크 문서를 중심으로 Caret과 직접 소통하며 개발을 진행합니다. 하지만 프로젝트의 특성이나 태스크의 추상화 수준(예: 하나의 태스크가 하루 이상 소요되는 경우)에 따라, `work-logs/` 폴더를 활용하여 더 상세한 작업 계획 및 로그를 관리하는 방식도 유용할 수 있습니다.

아래는 `work-logs/`를 활용한 분석/계획(Plan) - 실행(Coding) - 보고(Report) - 피드백/반복(Loop) 단계별 협업 예시입니다. 이 방식은 사용자가 Caret에게 각 단계를 명시적으로 지시하며 진행하고, 그 상호작용을 통해 각 단계를 신중하게 검토하고 조율하는 학습 경험을 제공합니다.

**협업 환경에서의 `work-logs` 추가 고려사항:**
여러 사람이 함께 작업하는 경우, `work-logs` 아래 개인별 폴더를 만들고 Caret의 사용자 기본 규칙에 사용자 정보를 설정할 수 있습니다. `.caretrules`나 사용자별 설정을 통해 작업 폴더를 제한하거나, 태스크에 쓰기 가능한 자원을 명시하고 각 사용자에게 태스크를 할당하는 방식으로 협업을 운용할 수 있습니다.
다만 Caret은 때로 실수하거나 정보를 누락할 수 있음을 기억하는 것이 중요합니다. 따라서 명확한 규칙과 가이드 문서를 통해 Caret의 행동을 적극적으로 정의하고 관리하는 것이 효과적입니다. 이러한 문서는 단순한 프로젝트 기록이라기보다, Caret의 행동 지침을 규정하는 소프트웨어나 규약처럼 생각하는 것이 좋습니다.

    * **참고: Auto-approve 모드 활용 시**
        * 만약 Caret의 **Auto-approve 모드가 활성화**되어 있다면, Caret은 이러한 단계를 사용자의 매번의 승인 없이 **자동으로 이어서 수행**할 수도 있습니다.
        * 이러한 자동 진행이 가능한 이유는, 본 프로젝트의 `.caretrules` 파일과 `docs/documentation-guide.md` (특히 "태스크-문서-작성법") 등에 Caret의 작업 방식과 문서화 규칙이 사전에 잘 정의되어 있기 때문입니다. 즉, Caret은 잘 구조화된 문서와 규칙을 통해 "다음에 무엇을 해야 할지"를 스스로 판단하고 작업을 이어갈 수 있습니다. 교육생들은 이러한 문서 기반 자동화의 가능성을 이해하는 것도 중요합니다.

    1. **분석 및 계획 단계 (Plan)**
        * Caret에게 "오늘 만들 미니 프로젝트의 개발 계획을 `work-logs/` 폴더에 `YYYYMMDD-01-plan.md` 파일로 작성해줘." 라고 요청
        * Caret이 제시한 계획 검토 및 함께 수정
    2. **실행 단계 (Checklist & Coding)**
        * Caret에게 "계획에 따라 필요한 파일 구조를 만들고, FastAPI 기본 코드를 작성해줘. 그리고 `YYYYMMDD-01-checklist.md` 파일에 진행 상황을 기록해줘." 와 같이 단계별 요청
        * HTML 입력폼 (초안 작성, **처리 옵션 선택: 자동 개시/검토 후 개시** - `docs/page-design.md` 참조), FastAPI 엔드포인트 정의, **LangGraph 상태(State) 및 노드(Node) 정의 (콘텐츠 변환, Blogger 포스팅, 사용자 검토 로직 포함 - `docs/requirement.md`의 사용자 시나리오 참조), 그래프(Graph) 구성 및 간단한 테스트 코드 작성** 등을 Caret과 함께 조금씩 만들어나감
        * **단계별 테스트 및 검증 생활화:** 코드 변경 또는 기능 추가 시마다 Uvicorn 서버 로그, 브라우저 개발자 도구(콘솔, 네트워크 탭), 실제 UI 동작을 통해 기능이 올바르게 작동하는지, 오류는 없는지, 데이터는 예상대로 처리되는지 꼼꼼히 확인하고 Caret에게 피드백합니다.
        * Caret이 생성한 코드 리뷰 및 간단한 디버깅 참여
        * **LangGraph 변환 로직 수정 가이드 (프롬프트, 모델, 스타일 변경 시):**
            * **핵심 요구사항 정의**: 먼저 어떤 스타일로 변환하고 싶은지, 사용할 LLM 모델은 무엇인지 등 핵심 요구사항을 명확히 합니다. 이는 `docs/requirement.md` 문서의 "주요 기능 - 콘텐츠 스타일 변환" 섹션에 반영될 수 있습니다.
            * **개발 가이드 참조**: `docs/development-guide.md`의 "AI 워크플로우 설계 (LangGraph)" 섹션에서 `app/graph/nodes.py`의 `transform_content_node` (초기 변환) 및 `revise_content_node` (사용자 의견 기반 재변환) 함수가 어떤 역할을 하는지 이해합니다.
            * **LLM API 키 설정**: 사용할 LLM (예: Gemini)의 API 키를 `.env` 파일에 `GEMINI_API_KEY`로 올바르게 설정하고, `app/core/config.py`의 `Settings` 클래스에도 해당 키 변수가 정의되어 있는지 확인합니다.
            * **LLM 클라이언트 및 모델 변경**: `app/graph/nodes.py`의 `get_llm_client()` 함수에서 사용할 LLM 라이브러리(예: `ChatGoogleGenerativeAI`)와 모델명(예: `gemini-2.5-flash-preview-05-20`)을 수정합니다.
            * **프롬프트 수정**: `app/graph/nodes.py`의 `transform_content_node` 함수 내 `prompt_template_str` 변수의 내용을 원하는 변환 스타일과 결과 형식을 명확히 지시하도록 수정합니다. 사용자 의견을 반영하는 `revise_content_node`의 프롬프트도 필요시 함께 수정합니다.
            * **관련 태스크 문서 업데이트**: 만약 `docs/tasks/005-langgraph-basic-and-transform.md`와 같이 LLM 설정이나 프롬프트 정의와 직접적으로 관련된 태스크 문서가 있다면, 해당 문서의 내용도 실제 변경 사항에 맞게 업데이트합니다.
            * **테스트 및 검증**: 변경 사항 적용 후, 웹 애플리케이션을 실행하여 실제 입력값에 대해 의도한 대로 콘텐츠 변환이 이루어지는지, 그리고 터미널 로그를 통해 LLM 호출 및 응답이 정상적인지 확인합니다.
    3. **보고 단계 (Report)**
        * Caret에게 "오늘 진행한 작업 내용을 `YYYYMMDD-01-report.md` 파일로 요약해줘." 요청
    4. **피드백 및 반복 (Loop - 시간 부족 시 생략 또는 간략히)**
        * 만들어진 결과물을 보고 추가/수정하고 싶은 부분을 Caret에게 전달하여 계획(`plan.md`)부터 다시 반복하는 짧은 사이클 경험

5. 마무리 및 Q&A 

* 실습 내용 요약 및 결과물 리뷰
* AI 에이전트 개발의 미래와 발전 방향 논의
* 질의응답

## 🛠️ 준비물

* 개인 노트북 (인터넷 연결 필수)
* VS Code, Git 사전 설치 권장 (미설치 시 교육 시간에 함께 진행)
* GitHub 계정 (선택 사항, 코드 공유 및 협업 경험 희망 시)

## 📂 교육 자료 및 리소스

* 본 GitHub 저장소: [`https://github.com/aicoding-caret/multi-post-agent`](https://github.com/aicoding-caret/multi-post-agent)
    * 교육용 발표 자료: [Caret을 이용한 Multi Post Agent 오픈소스 프로젝트 교육 슬라이드](../resources/Caret을%20이용한%20Multi%20Post%20Agent%20오픈소스%20프로젝트%20교육%20슬라이드.pdf)
    * Caret VSIX 파일: [`https://github.com/aicoding-caret/multi-post-agent/blob/main/resources/caret/caret-dev-3.10.1-20250516-094208.vsix`](./resources/caret/caret-dev-3.10.1-20250516-094208.vsix)
    * 관련 문서 (본 `docs/` 폴더 내 위치):
        * [요구사항 명세서](./requirement.md)
        * [개발 가이드](./development-guide.md)
        * [페이지 디자인](./page-design.md)
        * [태스크 목록](./tasks/task-list.md)

---

**강사 참고 사항:**

* 각 단계별 시간 배분은 유동적으로 조절합니다.
* 참여자 수준에 맞춰 설명 깊이와 실습 난이도를 조절합니다.
* Caret의 응답 속도 및 네트워크 환경에 따라 실습 진행 속도가 달라질 수 있음을 인지합니다.
* 가장 중요한 것은 참여자들이 AI와 "함께" 무언가를 만들어가는 "바이브코딩"의 즐거움을 느끼는 것입니다.
